---
date: 2016-06-20 22:16:12+08:00
layout: post
title: 一起学java并发编程（七）：性能和可伸缩性
thread: 9
categories: java
tags: java并发编程
---
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

### 性能
为了利用并发来实现更好的性能，我们需要努力做两件事：更有效地利用我们现有的处理资源，让我们的程序尽可能地开拓更多可用的处理资源。从性能监视器的视角来看，这意味着我们希望CPU尽可能处于忙碌状态。

可伸缩性指的是：当增加计算资源的时候（比如增加额外CPU数量、内存、存储器、I/O带宽），吞吐量和生产量能够相应地得以改进。

性能的这两个方面——“有多快”和“有多少”是完全分离的，有时候甚至是相悖的。为了实现更好的可伸缩性，或者更好地利用硬件，我们通常会停止增加每个独立任务所要完成的工作量，比如我们把任务分解到多个管道线的子任务中。具有讽刺意味的是，大多数在单线程化的程序中提高性能的窍门，都会损害可伸缩性。

从性能中的多个角度来看，“有多少”方面——可伸缩性，吞吐量和生产量——在Server应用程序中往往比“有多快”受更多的关注。

避免不成熟的优化。首先使程序正确，然后再加快——如果它运行得还不够快。

大多数性能的决定需要多个变量，并且高度依赖于发生的环境。在决定某个方案比其他方案“更快”之前，先问你自己一些问题：
- 你所谓的更“快”指的是什么？  
- 在什么样的条件下你的方案能够真正运行得更快？在轻负载还是重负载下？大数据集还是小数据集？是否支持你的测量标准的答案？  
- 这些条件在你的环境中发生的频率？是否支持你的测量标准的答案？  
- 这些代码在其他环境的不同条件下被用到的可能性？  
- 你用什么样隐含的代价，比如增加的开发风险或维护性，换取了性能的提高？这个权衡的决定是否正确？  

对性能的追求很可能是并发bug唯一最大的来源。

### Amdahl定律
Amdahl定律描述了在一个系统中，基于可并行化和串行化的组件各自所占的比重，程序通过获得额外的计算资源，理论上能够加速多少。如果F是必须串行化执行的比重，那么Amdahl定律告诉我们，在一个N处理器的机器中，我们最多可以加速：

$$ Speedup \leq \frac{1}{F + \frac{(1 - F)}{N}} $$
当N无效增大趋近无穷时，speedup的最大值无限趋近1/F，这意味着一个程序中如果50%的处理都需要串行进行的话，speedup只能提升2倍。

所有的并发程序都有一些串行源；如果你认为你没有，那么仔细检查吧。

减小锁的粒度，使用并发性良好的串行源。分离锁（把一个锁分拆成多个锁）和分拆锁（把一个锁分拆成两个锁）能够减小串行源锁的粒度，看上去没能在利用多处理器上帮助我们很多。但是实际效果却很好，因为分离出的数量可随着处理器数量的增加而增长。

### 线程开销
调度和线程内部的协调器都要付出性能的开销；对于性能改进的线程来说，并行带来的性能优势必须超过并发所引入的开销。

线程切换引入的JVM和OS活动的开销并不是切换上下文开销的唯一来源。当一个新的线程被换入后，它所需要的数据可能不在当前处理器本地的缓存中，所以切换上下文会引起缓存缺失的小恐慌，因此线程在第一次调度的时候会运行得稍慢一些。

如果线程频繁发生阻塞，那线程就不能完整使用它的调度限额了。一个程序发生越多的阻塞，与受限于CPU的程序相比，就会造成越多的上下文切换，这增加了调度的开销，并减少了吞吐量。

性能的开销有几个来源。synchronized和volatile提供的可见性保证要求使用一个特殊的、名为存储关卡的指令，来刷新缓存，使缓存无效，刷新硬件的写缓存，并延迟执行的传递。存储关卡可能同样会对性能产生影响，因为它们抑制了其他编译器的优化；在存储关卡中，大多数操作是不能被重排序的。synchronized机制对无竞争同步进行了优化（volatile总是非竞争的）。现代JVM能够通过优化，解除经确证不存在的锁，从而减少同步。更加成熟的JVM可以使用逸出分析来识别本地对象的引用并没有在堆中被暴露，并且因此成为线程本地的。即使没有逸出分析，编译器同样可以进行锁的粗化，把邻近的synchronized块用相同的锁合并起来。

不要过分担心非竞争的同步带来的开销，基础的机制已经足够快了，在这个基础上，JVM能够进行额外的优化，大大减少或消除了开销。关注那些真正发生了锁竞争的区域中性能的优化。

非竞争的同步可以由JVM完全掌握；而竞争的同步可能需要OS的活动，这会增大开销。当锁为竞争性的时候，失败的线程必然发生阻塞。JVM既能自旋等待，或者在操作系统中挂起这个被阻塞的线程。哪一个效率更高，取决于上下文切换的开销，以及成功地获取锁需要等待的时间这两者之间的关系。自旋等待更适合短期的等待，而挂起适合长时间等待。

### 减少锁竞争
串行化会损害可伸缩性，上下文切换会损害性能。竞争性的锁会同时导致这两种损失，所以减少所得竞争能够改进性能和可伸缩性。并发程序中，对可伸缩性首要的威胁是独占的资源锁。

有两个原因影响着锁的竞争性：锁被请求的频率，以及每次持有该锁的时间。

有三种方式来减少锁的竞争：
- 减少持有锁的时间；  
- 减少请求锁的频率；  
- 或者用协调机制取代独占锁，从而允许更强的并发性。  


### 减少上下文切换的开销